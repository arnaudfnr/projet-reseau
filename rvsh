#! /bin/bash

#include <unistd.h>

#######################################################################################################
#			fonction interaction
#
# $1(machine)	 $2(user) $3 	(user précédent)
# On distingue les prompts admin et user et on les affiche dans une boucle infinie
# récupération du nom de la commande et de ses arguments, vérification du type puis ajout du préfixe commande ou admin selon les cas
# appel de la fonction commande en lui envoyant les arguments
#
# Dans la partie user : 
# La commande exit doit permettre de se reconnecter à l'utilisateur précédent et s'il y en a un, son nom est stocké dans $3 (voir "su" et "connect") d'où la condition. 
# Une autre condition teste si le fichier msgnom_utilisateur existe. Si c'est le cas, une discussion a été ouverte par un autre utilisateur.
# On récupère alors le nom et la machine de l'envoyeur renseigné dans le fichier (cf commande-write) et on lance la commande write avec la réponse de l'utilisateur (formée par les 3 arguments du read)
#
########################################################################################################

function interaction() {
	while true
	do
		if [ $2 = "admin" ]; then
			echo -e "\nrvsh > \c"
			read cmd arg1 arg2
			
			if [ "$(type -t admin-$cmd)" = "function" ]; then 
				admin-$cmd NULL $2 $arg1 $arg2
			elif [ "$(type -t commande-$cmd)" = "function" ]; then
				commande-$cmd NULL $2 $arg1 $arg2
			else
				echo "Commande non comprise !"
			fi
			
		else
			echo -e "\n$2@$1 > \c"
			read cmd arg1 arg2
			fun="commande-$cmd"	
			if [ "$(type -t $fun)" = "function" ]; then
				if [ $cmd = "exit" ]; then
					arg1=$3 
				fi
	   			$fun $1 $2 $arg1 "$arg2"

			elif [ -e msg$2 ]; then
				sender=$(cat msg$2 | cut -d @ -f 1)
				mach=$(cat msg$2 | cut -d \> -f 1 | cut -d @ -f 2)
				commande-write $1 $2 $sender@$mach "$cmd $arg1 $arg2"
			else
	  			echo "Commande non comprise !"
			fi	
		fi

	done
}


######################################################################################################
#			fonction connection
#
# $1(machine)	 $2(user)    $3 (user précédent)
# on test si l'utilisateur a le droit de se connecter à la machine
# on test si le mdp est celui renseigné dans le fichier users (pour cela on récupère la partie derrière le 3e ; à la ligne de l'user 
# on récupère la date au format "jour mois année heure" puis on écrit les informations dans le fichier Connexions (qui contient tous les utilisateurs actuellement connectés et sur quelle(s) machine(s))
# On va ensuite modifier le fichier usersinfos (utilisé pour la commande finger) pour mettre à jour la dernière date de connexion ainsi que le terminal utilisé.			
# Pour cela on récupère tous les champs sauf les deux derniers (terminal et date) qui doivent être mis à jour puis on les envoie dans un fichier temporaire.
# On supprime l'ancienne ligne puis on ajoute la nouvelle dans le fichier usersinfos.
# appel de la fonction interaction en lui envoyant machine et user (et l'user précédent si l'on se connecte à partir de la commande su ou conect)
#
########################################################################################################

function connection() {
	if test $(grep $2 users | grep -o $1) = $1
		then
			echo -e "Rentrez votre mot de passe : \c"
			read -s mdp
			if [ $mdp = $(grep $2 users | cut -d \; -f 3) ]; then
			
					date=$(date | cut -d \( -f 1 ) 
					echo "$2 ; $1 ; $date" >> Connexions
					i=`expr $(cat Champs | wc -l) - 2`
					echo -e "$(cat usersinfos | grep  $2 | cut -d \; -f 1-$i;$tty ;$date" > tmp
					sed -i "/$2/d" usersinfos
					cat tmp >> usersinfos
					rm tmp
		
					interaction $1 $2 $3
			else
				echo -e "\nMauvais mot de passe !"
				connection $1 $2 $3
			fi
					
	else 
		echo "Vous n'avez pas les droits !"
	fi

}

######################################################################################################
#			fonction connection-admin
#
# 
# connection en mode admin
# vérification du mdp en le comparant à celui stocké dans le fichier spécial passAdmin
# appel de la fonction interaction en lui envoyant NULL pour la machine et admin en user
#
########################################################################################################

function connection-admin(){
	echo -e "Rentrez votre mot de passe : \c"
	read -s mdp

	if [ $mdp = $(cat passAdmin) ]; then					
		interaction NULL admin
	else
		echo -e "\nMauvais mot de passe !"
		connection-admin
	fi
}


function commande-su() {
	if [ -n $3 ]; then
		cpt=`expr $cpt + 1`
		connection $1 $3 $2 #on donne en argument le nom de la machine, le nom du nouvel utilisateur ainsi que le nom de 			l'utilisateur précédent.	
	else 
		erreur
	fi
}

function commande-connect() {
	if [ -n $3 ]; then
		cpt=`expr $cpt + 1`
		connection $3 $2 $1
	else 
		erreur
	fi
}

function commande-passwd() {
	local pass pass2
	echo -e "\nChangement de mot de passe pour $2"
        echo -e "Mot de passe actuel : \c"
	read -s pass
	if [ $2 = "admin" ]; then pass2=$(cat passAdmin) 
	else pass2=$(grep $2 users | cut -d \; -f 3)
	fi
	if [ $pass =  $pass2 ] ; then
		echo -e "\nNouveau mot de passe : \c"
		read -s pass
		echo -e "\nConfirmer le nouveau mot de passe : \c"
		read -s pass2
		if [ $pass = $pass2 ] ; then
			sed -i 's/'$2';\(.*\);.*/'$2';\1; '$pass'/' users
		else 
			echo "Les mots de passe sont différents !" 
			commande-passwd $1 $2 $3
		fi
	else 
		echo "Mauvais mot de passe !"
		commande-passwd $1 $2 $3
	fi	
}

function commande-write() {
	local receiver=$(echo $3 | cut -d @ -f 1)
	local mach=$(echo $3 | cut -d @ -f 2)
	
	if [ "$4" = "exit" ]; then 
			rm msg$receiver 2>> erreur.log
			rm msg$2 2>> erreur.log
	else
		if [ $(cat Connexions | grep $receiver | grep -c $mach) -ge 1 ]; then 
			term=$(cat usersinfos | grep $receiver | cut -d \; -f 4)
			echo "" > \/dev\/$term
			echo "$2@$1 > $4" > \/dev\/$term
			echo "$2@$1 > $receiver@$mach : $4" >> msg$receiver
			read msg
			commande-write $1 $2 $3 "$msg"
		else 
			echo "L'utilisateur n'est pas connecté à la machine !"
		fi
	
	fi
	
}

function commande-who() {
	if [ $1 = NULL ]; then
		echo "Vous n'êtes connectés à aucune machine"
	else
		cat Connexions | grep $1 | cut -n -d \; -f 1,3
	fi
}

function commande-rusers() { 
	cat Connexions 
}

function commande-rhost() { 
	cat machines 
}

function commande-finger() {
	#fich="NULL"
	#if [ $2 = "admin" ] ; then
	#	echo "Quels informations afficher ?"
	#	PS3="Votre choix : "
	#	select choix in "Tous les utiliateurs" "Les utilisateurs connectés";
	#	do
	#		case $REPLY in 
	#		1) 	fich="users"
	#			break;;
	#		2) 	fich="Connexions"
	#			break;;
	#		*) 	echo "Chox non compris";;
	#		esac
	#	done
	#		
	#	while read user
	#	do
	#		i=1
	#		user=$(echo $user | cut -d \; -f 1)
	#		while read champ
	#		do
	#			echo "$champ  : $(cat usersinfos | grep $user | cut -d \; -f $i)" 
	#			i=`expr $i + 1` 
	#		done < Champs
	#	done < $fich
	#else
	if [ $2 = "admin" ] ; then
		echo -e "Administrateur \n Connecté au terminal pts/$tty \nDate de connexion : $date"
	else
		local i=1 champ
		while read champ
		do
			echo "$champ  : $(cat usersinfos | grep $2 | cut -d \; -f $i)"
			i=`expr $i + 1` 
		done < Champs
	fi
}

function admin-host(){
	echo "liste des machines du réseau"
	cat machines
	select choix in "Ajouter une machine" "Supprimer une machine" "Ne rien faire"
	do
		case $REPLY in
			1) echo "Entrer le nom de la machine à ajouter"
			   read nom
			   echo "$nom" >> machines
			   break;;
			2) echo "Entrer le nom de la machine à supprimer"
			   read nom
			   sed -i "/$nom/d" machines
			   break;;
			3) break;;
			*) echo "Choix non compris !";;
		esac
	done
}

function admin-users(){
	local mdp mdp2
	echo -e "\nListe des utilisateurs"
	cat users | cut -d \; -f 1 
	select choix in "Ajouter un utilisateur" "Supprimer un utilisateur" "Modifier les droits d'un utilisateur" "Modifier le mot de passe d'un utilisateur" "Ne rien faire"
	do
		case $REPLY in
			1) echo -e "\nEntrer le nom du nouvel utilisateur : \c"
			   read nom
			   while [ $mdp != $mdp2 ]
			   do
				echo -e "Entrer le mot de passe du nouvel utilisateur : \c"
				read -s mdp
				echo -e "\nConfirmer le mot de passe : \c"
				read -s mdp2
				if [ $mdp != $mdp2 ] ; then 
					echo -e "\nLes mots de passe sont différents !" 
				fi
			   done   
		           echo "Entrer la liste des machines auxquelles l'utilisateur peut se connecter en les séparant par un espace"
			   read machine
		           echo "$nom; $machine ; $mdp" >> users
			   echo "$nom;" >> usersinfos
		           break;;

			2) ask-nom
			   sed -i "/$nom/d" users
			   sed -i "/$nom/d" usersinfos
			   break;;

			3) ask-nom
			   echo -e "\nliste des machines de $nom :"
			   echo -e "$(cat users | grep $nom | cut -d \; -f 2)\n"
				
			   select choix in "Retirer des droits" "Ajouter des droits" "Ne rien faire"
			   do
				   case $REPLY in
					1) echo -e "\nRentrer le nom des machines à retirer à $nom en les séparant par un espace"
					   read machines
					   i=1
					   while [ $i -le $(echo $machines | wc -w) ] 
					   do
						mach=$(echo $machines | cut -d ' ' -f $i)
						cat users | grep $nom | sed -i "s/$nom;\(.*\)$mach \(.*\)/$nom;\1\2/" users
						i=`expr $i + 1`
					   done
					   break;;
						
					2) echo -e "\nRentrer le nom des machines à ajouter à $nom en les séparant par un espace"
					   read machines
					   droit=$(echo -e "$(cat users | grep $nom | cut -d \; -f 2)$machines\c")
					   sed -i "s/$nom;.*;\(.*\)/$nom;$droit;\1/" users
					   break;;

					3) break;;
					*) echo "Choix incorrect";;
				   esac
			   done
			   break;;

			4) ask-nom
			   echo -e "\nChoisir un nouveau mot de passe"
			   read mdp
			   sed -i "s/$nom;\(.*\);.*/$nom;\1; $mdp/" users
			   break;;

			5) break;;
			*) echo "Choix non compris !";;

		esac
	done
}

function ask-nom() {
	echo -e "\nEntrer le nom d'utilisateur : \c"
	read nom
	verif-nom $nom
}

function verif-nom() {
	if [ -z "$(cat users | grep $1)" ]; then
		echo "L'utilisateur n'existe pas !"
		ask-nom
	fi
}
	
function erreur() { 
	echo "Il y a une erreur. Veuillez recommencer." 
}

function commande-exit() {
	if [ $cpt -ge 1 ] ; then
		cpt=`expr $cpt - 1`
		fichCo $1 $2
		break
	elif [ $cpt -eq 0 ] ; then
		fichCo $1 $2
		rm erreur.log
		exit 0
	else 
		erreur
	fi
}	

function fichCo() {
	mv Connexions Connexionstmp
	cat Connexionstmp | grep -v ".*$2.*$1.*" > Connexions
	rm Connexionstmp
}

# récupération du numéro de terminal (pts/n)
tty=$(tty | cut -d \/ -f 3,4)
cpt=0
PS3="Votre choix ? "

if test $# -ge 1
then
	case $1 in
	
	-connect) if test $# -ge 3	# test pour savoir si l'user a bien envoyé tous les args
		  then
			  connection $2 $3 	# $2(machine)	$3(user)
		  else
			erreur
		  fi;;
	-admin) connection-admin;;
	*) erreur;;
	esac
else 
	erreur
fi
